# Use optimizing scheduling
# YES
# NO : No scheduling is done.
# HOT_ONLY: Only use scheduler with hot functions.
USE_OPT_SCHED HOT_ONLY 

# Print spill counts
# Same options as use optimal scheduling.
PRINT_SPILL_COUNTS YES

# Use two pass scheduling approach.
# First pass minimizes RP and second pass tries to balances RP and ILP.
# YES
# NO
USE_TWO_PASS YES

# Order of passes to run delimited by a comma with no space. Only enabled with
# USE_TWO_PASS YES. Note that if both the regular ILP Pass and the ILP Reduced
# Latency Pass are enabled then only timed out regions in the regular ILP pass
# will be selected to be re-schedule in the Reduced Latency Pass.
# VALUES:
# OCC - Occupancy Pass
# ILP - Regular ILP Pass
# ILP_RL - ILP Reduced Latency Pass
# Valid orderings: OCC,ILP or OCC,ILP_RL or OCC,ILP,ILP_RL
PASS_ORDER OCC,ILP

# If latency for an edge is greater than this amount then reduce the latency by
# LATENCY_DIVISOR.
LATENCY_TARGETS 1

# The amount to divide the original latency by.
LATENCY_DIVISOR 1

# The minimum amount latency can be reduced to.
LATENCY_MINIMUM 1

# Enable a final pass with original latencies to gather compile-time data since
# the ILP Reduce Latency pass will have invalid schedule lengths. In this pass
# only the sequential list scheduler will be enabled and enumerator disabled.
COMPILE_TIME_DATA_PASS NO

# These 3 flags control which schedulers will be used.
# Each one can be individually toggled. The heuristic
# list scheduler or ACO must be run before the
# enumerator.
# VALUES:
# YES
# NO
# HEUR_ENABLED is the Heuristic scheduler.
HEUR_ENABLED YES
# ACO_ENABLED NO
ACO_ENABLED YES
# ENUM_ENABLED YES
ENUM_ENABLED NO

# Controls when ACO should be run, either before or
# after the enumerator. Both can be enabled at the
# same time. ACO is disabled if both are disabled.
# Run ACO before the enumerator
# VALUES:
# YES
# NO
ACO_BEFORE_ENUM YES
# Run ACO after the enumerator
ACO_AFTER_ENUM NO

# A time limit for the whole region (basic block) in milliseconds. Defaults to no limit.
# Interpretation depends on the TIMEOUT_PER setting.
# Not used when the two pass scheduling approach is enabled.
REGION_TIMEOUT 5

# A time limit for each schedule length in milliseconds. Defaults to no limit.
# Interpretation depends on the TIMEOUT_PER setting.
# Not used when the two pass scheduling approach is enabled.
LENGTH_TIMEOUT 5

# A time limit for the whole region in milliseconds. Defaults to no limit.
# Only used when two pass scheduling is enabled.
# A time limit for the whole region.
FIRST_PASS_REGION_TIMEOUT 5
# A time limit for each schedule length.
FIRST_PASS_LENGTH_TIMEOUT 5

# A time limit for the second pass in milliseconds.
# Only used when two pass scheduling is enabled.
# A time limit for the whole region.
SECOND_PASS_REGION_TIMEOUT 5
# A time limit for each schedule length.
SECOND_PASS_LENGTH_TIMEOUT 5

# How to interpret the timeout value? Valid options:
# INSTR : multiply the time limits in the above fields by the number of
# instructions in the block
# BLOCK : use the time limits in the above fields as is
TIMEOUT_PER INSTR

# The heuristic used for the list scheduler. Valid values are any combination of:
# CP: critical path
# LUC: last use count
# UC: use count
# SC: successor count
# NID: node ID
# LLVM: LLVMâ€™s default list scheduler order
# Example: LUC_CP_NID
HEURISTIC NID
LIST_HEURISTIC NID

# The heuristic used for the enumerator. If the two pass scheduling
# approach is enabled, then this value will be used for the first pass.
# Same valid values as HEURISTIC.
ENUM_HEURISTIC NID

# The heuuristic used for the enumerator in the second pass in the two-pass scheduling approach.
# Same valid values as HEURISTIC.
SECOND_PASS_ENUM_HEURISTIC NID

# The heuristic used for a portion of blocks in ACO. If ACO is run on the host, only
# ACO_HEURISTIC1 will be used. If the two pass scheduling approach is enabled, then this
# value will be used for the first pass.
# Same valid values as HEURISTIC
ACO_HEURISTIC NID

# The heuristic used for ACO in the second pass in the two-pass scheduling approach. If
# ACO is run on the host, only ACO_HEURISTIC_SECOND_PASS1 will be used.
# Same valid values as HEURISTIC
ACO_HEURISTIC_SECOND_PASS1 NID
ACO_HEURISTIC_SECOND_PASS2 NID

# The spill cost function to be used. Valid values are:
# PERP: peak excess reg pressure
# PRP: peak reg pressure
# SUM: sum of excess reg pressures across the block
# PEAK_PLUS_AVG: peak excess reg pressure plus the avg reg pressure across the block
# SLIL: sum of live interval lengths for each block
# SPILLS: number of spills after running a register allocator (doesn't work with enumerator)
# TARGET: use target specific register pressure tracking
SPILL_COST_FUNCTION TARGET

# The weight of the spill cost in the objective function. This factor
# defines the importance of spill cost relative to schedule length. A good
# value for this factor should be found experimentally, but is is expected
# to be large on architectures with hardware scheduling like x86 (thus
# making spill cost minimization the primary objective) and smaller on
# architectures with in-order execution like SPARC (thus making scheduling
# the primary objective).
SPILL_COST_WEIGHT 100

# Precision of latency info:
# PRECISE: use precise latencies from the machine_model.cfg file
# LLVM: use latencies from LLVM
# UNIT: use unit latencies
LATENCY_PRECISION LLVM

# The scheduler used to find an initial feasible schedule.
# LIST: List scheduler
# SEQ: Sequential list scheduler
HEUR_SCHED_TYPE LIST

#use 3-tournament
ACO_TOURNAMENT NO

#use fixd value for bias or not. If not, use ratio instaed
ACO_USE_FIXED_BIAS YES

# Upper bound calculation for ready list
# NO: use number of instructions
# MIN_DEGREE: use the smallest degree across all instructions
# ANNIHILATION: use Annihilation number of the DAG
ACO_READY_LIST_UB MIN_DEGREE

#Fixed number of evaporation
ACO_FIXED_BIAS 5
ACO2P_FIXED_BIAS 5

# 0 to 1, ratio that will use bias
ACO_BIAS_RATIO 0.995

ACO_LOCAL_DECAY 0.1

ACO_DECAY_FACTOR 0.8
ACO2P_DECAY_FACTOR 0.8

#Number of ants will be number of blocks multiplied by NUMTHREADSPERBLOCK in aco.h
#Example: 40 blocks * 64 NUMTHREADSPERBLOCK = 2560 ants
ACO_DEVICE_ANT_PER_ITERATION_BLOCKS 180
#ACO_HOST_BLOCKS 80
ACO_ANT_PER_ITERATION 11520
HOST_ANTS 11520
#ACO_HOST_BLOCKS 1

ACO_MANY_ANTS_ENABLED NO
#Keep this the same as NUMBLOCKSMANYANTS in aco.h
ACO_MANY_ANTS_PER_ITERATION_BLOCKS 40

ACO_TRACE NO

#If you want to use pheromone table debugging set ACO_DBG_REGIONS
#to have a pipe '|' seperated list of scheduling regions that you want the
#pheromone tables for. Terminate the list with a pipe symbol or the last list
#item will not be debugged.
#To convert the files stored in ACO_DBG_REGIONS_OUT_PATH to a pdf see
#util/aco_analysis/make_pheromone_pdfs.sh
#Examples:
#ACO_DBG_REGIONS kernel_c2_sdk_0:1|
#ACO_DBG_REGIONS kernel_c2_sdk_0:1|other_region|
#ACO_DBG_REGIONS kernel_c2_sdk_0:1|other_region|even_more_regions|
ACO_DBG_REGIONS NONE

ACO_DBG_REGIONS_OUT_PATH ~/path_to_graph_output_directory/

# The importance of the heuristic in ACO. ACO uses (1/heuristic)^importance, so
# importance of 0 means don't use the heuristic.
ACO_HEURISTIC_IMPORTANCE 1
ACO2P_HEURISTIC_IMPORTANCE 1

# ACO will stop after this many iterations with no improvement.
ACO_STOP_ITERATIONS 5
ACO2P_STOP_ITERATIONS 5
ACO_STOP_ITERATIONS_RANGE1 1
ACO2P_STOP_ITERATIONS_RANGE1 1
ACO_STOP_ITERATIONS_RANGE2 2
ACO2P_STOP_ITERATIONS_RANGE2 2
ACO_STOP_ITERATIONS_RANGE3 3
ACO2P_STOP_ITERATIONS_RANGE3 3
ACO_STOP_ITERATIONS_RANGE4 3
ACO2P_STOP_ITERATIONS_RANGE4 3

# Whether or not to run ACO on the device
DEV_ACO YES

# Whether LLVM mutations should be applyed to the DAG.
LLVM_MUTATIONS NO

# (Chris) If using the SLIL cost function, enabling this option
# will force the B&B scheduler to skip DAGs with zero PERP.
FILTER_BY_PERP NO

# If a register type has a MAX pressure below a certain threshold it is ignored.
FILTER_REGISTERS_TYPES_WITH_LOW_PRP NO

# (Chris) This setting chooses which blocks to keep and which blocks to discard.
# The scheduler will fall back to LLVM if the block is discarded.
# Valid options:
#   ALL: always take the block
#   IMPROVED: only take improved blocks
#   OPTIMAL: only take optimal blocks
#   IMPROVED_OR_OPTIMAL: only take improved or optimal blocks
#   ZERO_COST: only take zero-cost blocks
BLOCKS_TO_KEEP ALL

# (Chris) Override USE_OPT_SCHED to apply to specific regions.
# When SCHEDULE_SPECIFIC_REGIONS is set to YES, the scheduler
# will only schedule the regions specified by
# REGIONS_TO_SCHEDULE, which is a comma-separated list of
# scheduling regions.
SCHEDULE_SPECIFIC_REGIONS NO
REGIONS_TO_SCHEDULE _Z6kernelI14inclusive_scanILN7rocprim20block_scan_algorithmE1EEdLj256ELj11ELj100EEvPKT0_PS4_:0 
#REGIONS_TO_SCHEDULE _ZN7rocprim6detail29init_offset_scan_state_kernelINS0_19lookback_scan_stateIjLb1ELb1EEEEEvT_jNS0_16ordered_block_idIjEE:1
#REGIONS_TO_SCHEDULE _Z16operation_kernelIdLj256ELj4EL23memory_operation_method0E9operationIL16kernel_operation2EdLj4ELj256EELi0EEvPT_S5_T3_:1

# Whether to use suffix concatenation. Disabled automatically if
# history domination is disabled.
ENABLE_SUFFIX_CONCATENATION NO

# Where to perform graph transformations. Valid values are any combination of:
# BH - before heuristic; run on all blocks that we schedule
# AH - after heuristic; only if the heuristic scheduler doesn't prove optimality
GT_POSITION AH

# Where to perform graph transformations for the second pass.
# Valid values are the same as with GT_POSITION.
# However, note that the sequential list scheduler is practically never
# going to give an optimal schedule, so BH is almost certainly superior.
2ND_PASS_GT_POSITION BH

# Whether to apply the node superiority graph transformation.
STATIC_NODE_SUPERIORITY NO

# Whether to apply node superiority in multiple passes.
MULTI_PASS_NODE_SUPERIORITY NO

# Whether to apply relaxed pruning. Defaults to YES.
APPLY_RELAXED_PRUNING YES

# Whether to apply spill-cost pruning. Defaults to YES.
APPLY_SPILL_COST_PRUNING YES

# Whether to apply history-based domination. Defaults to YES.
APPLY_HISTORY_DOMINATION YES

# Use simple register types. In the machine scheduler this means
# use the first PSet associated with a RegUnit.
USE_SIMPLE_REGISTER_TYPES NO

# Should we simulate register allocation to the evaluate the effect
# of scheduling decisions on estimated spill count.
# BEST: Only simulate RA with the best (lowest cost) schedule.
# LIST: Only simulate RA with the list schedule.
# BOTH: Simulate RA using the best schedule and the list schedule.
# TAKE_SCHED_WITH_LEAST_SPILLS: Simulate RA using the best schedule and the list schedule, and
# take the schedule that generates the least spills.
# NO: Do not simulate register allocation.
SIMULATE_REGISTER_ALLOCATION BEST

# Should we ignore ilp and only schedule for register pressure.
SCHEDULE_FOR_RP_ONLY NO

# Whether to enumerate schedules containing stalls (no-op instructions).
# In certain cases, such as having unpipelined instructions, this may
# result in a better schedule. Defaults to YES.
ENUMERATE_STALLS YES

# Whether to generate missing parts of the machine model using information from LLVM.
# Requires a generator class for the target in machine_model.cfg.
GENERATE_MACHINE_MODEL NO

#The algorithm to use for determining the lower bound. Valid values are:
# RJ: Rim and Jain's algorithm.
# LC: Langevin and Cerny's algorithm.
# Defaults to LC.
LB_ALG LC

# Whether to verify that calculated schedules are optimal. Defaults to NO.
VERIFY_SCHEDULE YES

# Whether to apply dynamic node superiority. Defaults to NO.
DYNAMIC_NODE_SUPERIORITY NO

# An option to treat data dependencies of type ORDER as data dependencies.
TREAT_ORDER_DEPS_AS_DATA_DEPS NO

# The number of bits in the hash table used in history-based domination.
HIST_TABLE_HASH_BITS 16

TIMEOUT_PER_MEMBLOCK_RATIO 100

# Whether to dump the DDG for all the regions we schedule.
# This is a debugging option.
DUMP_DDGS NO

# Where to dump the DDGs
# DDG_DUMP_PATH ~/ddgs

# Set the random seed. If the seed is set to 0, use the time as a seed
RANDOM_SEED 3

# Whether or not we want to limit our occupancy to a target below the theoretical max
SHOULD_LIMIT_OCCUPANCY YES

# What should we use to limit the occupancy?
# HEURISTIC: AMD's memory boundedness heuristic
# FILE: occupancy_limits.ini file
# NONE: do not use limits -- defaults to unlimited
OCCUPANCY_LIMIT_SOURCE NONE

# The value of occupancy (1-10) at which we no longer try to optimize RP 
OCCUPANCY_LIMIT 10

CYCLES_FROM_OPTIMAL 21

LOOP_DEPTH -1

USE_WEIGHTED_SECOND_PASS NO
