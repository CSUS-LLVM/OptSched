#!/usr/bin/python3
'''
**********************************************************************************
Description:    This script is meant to be used with the OptSched scheduler and
                the run-plaidbench.sh script. This script will extract basic stats
                about the benchmarks from the log files generated by the
                run-plaidbench.sh script.
Author:         Vang Thao
Last Update:    September 2020
**********************************************************************************

OUTPUT:
    This script takes in data from plaidbench runs and output a single spreadsheet.
        Spreadsheet 1: benchmarks-stats.xlsx

Requirements:
    - python3
    - pip3
    - openpyxl (sreadsheet module, installed using pip3)

HOW TO USE:
    1.) Run a plaidbench benchmarks with run-plaidbench.sh to generate a
        directory containing the results for the run.
    2.) Pass the path to the directory as an input to this script with
        the -i option.

Example:
    ./get-benchmarks-stats.py -i /home/tom/plaidbench-optsched-01/

    where plaidbench-optsched-01/ contains
        densenet121
        densenet169
        ...
        ...
'''

import argparse
import logging
import os
import sys
from openpyxl import Workbook
from openpyxl.styles import Font

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from readlogs import *

def parseStats(filePaths):
    """
    Parse and process the logs from the selected benchmark runs then return the statistics in a dictionary.

    Parameters:
    inputFolder -- A string containing the name of a directory with plaidbench or SHOC results.

    Returns:
    dictionary: A dictionary containing the statistics for the benchmark.
        The key is the name of the files which are mapped to another dictionary containing the keys
        regions, kernels, insts, and maxRegionSize which are mapped to integer values.
    """
    # Get logger
    logger = logging.getLogger('parseStats')

    # Overall stats for the benchmark suite
    stats = {}

    # Begin stats collection for this run
    for bench in filePaths:
        # first check if log file exists.
        if os.path.exists(filePaths[bench]):
            # Open log file if it exists.
            with open(filePaths[bench]) as file:
                # Initialize current benchmark statistics
                curStats = {}
                curStats['kernels'] = 0
                curStats['regions'] = 0
                curStats['insts'] = 0
                curStats['average'] = -1
                curStats['maxRegionSize'] = -1

                # Read the whole log file
                # and split the scheduling
                # regions into a list
                log = file.read()
                blocks = split_blocks(log)

                # Iterate over each scheduling region
                for block in blocks:
                    events = keep_only_first_event(parse_events(block))

                    # Ignore second pass since it should
                    # have the same stats as first
                    if ('PassFinished' in events.keys() and events['PassFinished']['num'] == 2):
                        continue

                    # Get DAG stats
                    dagName = events['ProcessDag']['name']
                    inst = events['ProcessDag']['num_instructions']

                    # Split kernel name from its region number
                    names = dagName.split(':')
                    regionNum = names[1]

                    # Region 0 indicates a new kernel
                    if regionNum == '0':
                        curStats['kernels'] += 1

                    curStats['insts'] += inst
                    curStats['regions'] += 1
                    if inst > curStats['maxRegionSize']:
                        curStats['maxRegionSize'] = inst

                if curStats['regions'] != 0:
                    curStats['average'] = curStats['insts'] / \
                        curStats['regions']

                # Save stats for this benchmark
                stats[bench] = curStats

        # If the file doesn't exist, output error log.
        else:
            logger.warning(
                'Cannot find log file for benchmark {}.'.format(bench))

    return stats


def printStats(stats):
    '''
    Prints the recorded statistics in a human readable format.

    Parameters:
    stats -- A dictionary mapping a benchmark to its statistics
    '''
    # Overall statistics variables
    totalKernels = 0
    totalRegions = 0
    totalInsts = 0
    totalAverageRegionSize = -1

    # Statistics for individual benchmarks
    for bench in stats:
        print('Benchmark: {}'.format(bench))
        print('    Kernels : {}'.format(stats[bench]['kernels']))
        totalKernels += stats[bench]['kernels']
        print('    Scheduling Regions : {}'.format(stats[bench]['regions']))
        totalRegions += stats[bench]['regions']
        print('    Instructions : {}'.format(stats[bench]['insts']))
        totalInsts += stats[bench]['insts']
        averageRegionSize = -1
        if stats[bench]['regions'] != 0:
            averageRegionSize = stats[bench]['insts'] / stats[bench]['regions']
        print('    Average Region Size : {:.2f}'.format(averageRegionSize))

    # Statistics for the overall benchmark suite
    print('Overall Statistics')
    print('    Kernels : {}'.format(totalKernels))
    print('    Scheduling Regions : {}'.format(totalRegions))
    print('    Instructions : {}'.format(totalInsts))
    if totalRegions != 0:
        totalAverageRegionSize = totalInsts / totalRegions
    print('    Average Region Size : {:.2f}'.format(totalAverageRegionSize))


def createSpreadsheets(stats, outputFile):
    '''
    Write the dictionary returned from parseStats to an excel spreadsheet.
    Also calculate and print the average region size and the overall statistics.

    Parameters:
    stats -- A dictionary containing the statistics for the benchmarks.
    outputFile -- A string containing the desired name for the output spreadsheet.
    '''
    # Check if the user specified an extension with xls or xlsx
    # If not then add the extension to the string
    if 'xls' not in outputFile[-4:]:
        outputFile += '.xlsx'

    # Create new excel worksheet
    wb = Workbook()

    # Grab the active worksheet
    ws = wb.active

    # Insert title and benchmark names
    ws['A1'] = 'Benchmarks'
    ws['A1'].font = Font(bold=True)

    row = 3

    totalKernels = 0
    totalRegions = 0
    totalInsts = 0
    maxRegionSize = -1
    totalAverageRegionSize = -1
    totalNumberOfBenchmarks = 0

    # Handle writing to spreadsheet for each benchmarks
    for bench in stats:
        totalNumberOfBenchmarks += 1

        averageRegionSize = -1

        ws['A' + str(row)] = bench
        ws['B' + str(row)] = 'Total number of kernels'
        ws['C' + str(row)] = stats[bench]['kernels']
        totalKernels += stats[bench]['kernels']

        ws['B' + str(row+1)] = 'Total number of scheduling regions'
        ws['C' + str(row+1)] = stats[bench]['regions']
        totalRegions += stats[bench]['regions']

        ws['B' + str(row+2)] = 'Total number of instructions'
        ws['C' + str(row+2)] = stats[bench]['insts']
        totalInsts += stats[bench]['insts']

        if stats[bench]['regions'] != 0:
            averageRegionSize = stats[bench]['insts'] / stats[bench]['regions']
        ws['B' + str(row+3)] = 'Avg. Region Size'
        ws['C' + str(row+3)] = averageRegionSize

        ws['B' + str(row+4)] = 'Max Region Size'
        ws['C' + str(row+4)] = stats[bench]['maxRegionSize']
        if maxRegionSize < stats[bench]['maxRegionSize']:
            maxRegionSize = stats[bench]['maxRegionSize']

        row += 5

    # Write the overall statistics
    ws['A' + str(row)] = 'Overall Stats'
    ws['A' + str(row)].font = Font(bold=True)
    ws['B' + str(row)] = 'Total number of benchmarks'
    ws['C' + str(row)] = totalNumberOfBenchmarks
    ws['B' + str(row+1)] = 'Total number of kernels'
    ws['C' + str(row+1)] = totalKernels
    ws['B' + str(row+2)] = 'Total number of scheduling regions'
    ws['C' + str(row+2)] = totalRegions
    ws['B' + str(row+3)] = 'Total number of instructions'
    ws['C' + str(row+3)] = totalInsts
    if totalRegions != 0:
        totalAverageRegionSize = totalInsts / totalRegions
    ws['B' + str(row+4)] = 'Avg. Region Size'
    ws['C' + str(row+4)] = totalAverageRegionSize
    ws['B' + str(row+5)] = 'Max Region Size'
    ws['C' + str(row+5)] = maxRegionSize

    wb.save(outputFile)


def main(args):
    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)

    # Get filepaths for the selected benchmark suite
    filePaths = get_bench_log_paths(args.inputFolder, args.benchmark)

    # Start stats collection
    stats = parseStats(filePaths)

    # Print stats if enabled
    if args.verbose:
        printStats(stats)

    # Create spreadsheet
    if not args.disable:
        createSpreadsheets(stats, args.output)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Script to extract benchmarks stats',
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument(dest='inputFolder',
                        help='The path to a benchmark directory')

    parser.add_argument('--verbose', '-v',
                        action='store_true', default=False,
                        dest='verbose',
                        help='Print the stats to terminal')

    parser.add_argument('--output', '-o',
                        default='benchmarks-stats',
                        dest='output',
                        help='Output spreadsheet filepath')

    parser.add_argument('--disable', '-d',
                        action='store_true', default=False,
                        dest='disable',
                        help='Disable spreadsheet output.')

    parser.add_argument('--benchmark', '-b',
                        default='plaid',
                        choices=['plaid', 'shoc'],
                        dest='benchmark',
                        help='Select the benchmarking suite to parse for.')

    args = parser.parse_args()

    main(args)
