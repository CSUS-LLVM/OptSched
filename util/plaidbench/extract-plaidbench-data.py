#!/usr/bin/python3
'''
**********************************************************************************
Description:  Extract data from plaidbench runs. This script is meant to be used
              together with the run-plaidbench.sh script.
Author:       Vang Thao
Created:      November 26, 2019
Last Update:  December 30, 2019
**********************************************************************************

OUTPUT:
    This script takes in data from plaidbench runs and output 4 spreadsheets.
        Spreadsheet 1: compile_time.xls
        Spreadsheet 2: examples-per-second.xls
        Spreadsheet 3: tiles-per-second.xls
        Spreadsheet 4: execution_time.xls

Requirements:
    - python3
    - pip3
    - xlwt (spreadsheet module, installed using pip3)

HOW TO USE:
    1.) Run a plaidbench benchmarks with run-plaidbench.sh to generate a
        directory containing the results for the run.
    2.) Move the directory into a separate folder containing only the
        directories generated by the script.
    3.) Pass the path to the folder as an input to this script with
        the -i option.

Example:
    ./extract-plaidbench-data.py -i /home/tom/plaidbench-runs

    where plaidbench-runs/ contains
        plaidbench-optsched-01/
        plaidbench-optsched-02/
        ...
        plaidbench-amd-01/
        ...
'''

import os       # Used for scanning directories, getting paths, and checking files.
import xlwt     # Used to create excel spreadsheets.
import argparse # Used to parse commandline arguments

# Contains all of the stats
benchStats = {}

# List of benchmark names
benchmarks = [
    'densenet121',
    'densenet169',
    'densenet201',
    'inception_resnet_v2',
    'inception_v3',
    'mobilenet',
    'nasnet_large',
    'nasnet_mobile',
    'resnet50',
    'vgg16',
    'vgg19',
    'xception',
    'imdb_lstm',
]


def parseStats(inputFolder, ignoreFolders):
    scanDirPath = os.path.abspath(inputFolder)

    # Get name of all directories in current folder
    subfolders = [f.name for f in os.scandir(path=scanDirPath) if f.is_dir() ]

    # For each folder
    for folderName in subfolders:
        if folderName in ignoreFolders:
            continue

        name = folderName.split('-')

        # Get the run number from the end
        # of the folder name
        runNumber = name[-1]

        # Get the name of the run
        # and exclude the run number
        nameOfRun = '-'.join(name[:-1])

        # Create an entry in the stats for the
        # name of the run
        if (nameOfRun not in benchStats):
            benchStats[nameOfRun] = {}

        # Begin stats collection for this run
        statsForRun = {}
        total_compile_time = 0.00
        total_exe_time = 0.00
        for bench in benchmarks:
            # Get the path to the log file
            currentPath = os.path.join(inputFolder, folderName)
            currentPath = os.path.join(currentPath, bench)
            currentLogFile = os.path.join(currentPath, bench + '.log')
            stats = {}
            # Set default values
            stats['compile_time'] = 'Not Found'
            stats['inference_lat'] = 'Not Found'
            stats['fps'] = 'Not Found'

            # First check if log file exists.
            if (os.path.exists(currentLogFile)):
                # Open log file if it exists.
                with open(currentLogFile) as file:
                    for line in file:
                        test = line.split()
                        if (test):
                            if (test[0] == 'Example'):
                                # Remove the s character from string and convert the compile time
                                # to a floating point number
                                compile_time = float(test[3][:-1])
                                # Accumulate total compile time for this run
                                total_compile_time += compile_time
                                stats['compile_time'] = compile_time

                                # Remove the s character from string and convert the execution
                                # time to a floating point number
                                execution_time = float(test[5][:-1])
                                # Accumulate total execution time for this run
                                total_exe_time += execution_time
                                stats['execution_time'] = execution_time

                            elif (test[0] in benchmarks):
                                inference_lat = float(test[1])
                                fps = float(test[6])
                                stats['inference_lat'] = inference_lat
                                stats['fps'] = fps
            # If the file doesn't exist, output error log.
            else:
                print('Cannot find log file for {} run {} benchmark {}.'.format(nameOfRun, runNumber, bench))

            # Save stats for this benchmark
            statsForRun[bench] = stats

        # Save stats for this run
        benchStats[nameOfRun][runNumber] = statsForRun
        benchStats[nameOfRun][runNumber]['total_compile_time'] = total_compile_time
        benchStats[nameOfRun][runNumber]['total_exe_time'] = total_exe_time

# Print stats gathered by script to terminal.
def printStats():
    for nameOfRun in benchStats:
        print(nameOfRun)
        for runNumber in benchStats[nameOfRun]:
            print('    {}'.format(runNumber))
            for bench in benchStats[nameOfRun][runNumber]:
                if (bench == 'total_compile_time'):
                    print('        Total compile time: {:0.3f}'.format(benchStats[nameOfRun][runNumber][bench]))
                elif (bench == 'total_exe_time'):
                    print('        Total execution time: {:0.3f}'.format(benchStats[nameOfRun][runNumber][bench]))
                else:
                    print('        {}'.format(bench))
                    print('            Compile Time: {:0.3f}'.format(benchStats[nameOfRun][runNumber][bench]['compile_time']))
                    print('            Inference Latency: {:0.2f}'.format(benchStats[nameOfRun][runNumber][bench]['inference_lat']))
                    print('            FPS: {:0.2f}'.format(benchStats[nameOfRun][runNumber][bench]['fps']))

# Create compile time excel spreadsheet
def CreateCompileTimeSpreadsheet():
    # Create a new excel file
    file = xlwt.Workbook()
    # Create a new sheet in the excel file
    sh = file.add_sheet('Sheet 1')

    # Write the titles to the respective row
    # Use the function write(row, col, val)
    # to write to sheet 1
    # Note: 0,0 is row 1,1 in the spreadsheet
    sh.write(0,0, 'Benchmarks')
    # Set width for benchmark col
    # 36.5714285 is about equal to 1 pixel
    # Width of 18 is 131 pixels
    sh.col(0).width = 4790

    # Write benchmark names
    row = 2
    for bench in benchmarks:
        sh.write(row, 0, bench)
        row += 1
    sh.write(row, 0, 'Total')

    # Begin writing stats for compile times
    col = 1
    for nameOfRun in benchStats:
        # Write run name
        row = 0
        sh.write(row, col, nameOfRun)

        for runNumber in benchStats[nameOfRun]:
            # Write run number
            row = 1
            sh.write(row, col, 'Run {}'.format(runNumber))
            row += 1

            # Write compile time stats
            for bench in benchStats[nameOfRun][runNumber]:
                if (bench == 'total_compile_time'):
                    sh.write(row, col, benchStats[nameOfRun][runNumber][bench])
                elif (bench == 'total_exe_time'):
                    continue
                else:
                    sh.write(row, col, benchStats[nameOfRun][runNumber][bench]['compile_time'])
                row += 1

            # Go to next column for the next run.
            col += 1

    # Save file to current directory.
    file.save('compile_time.xls')

# Create execution time excel spreadsheet
def CreateExecutionTimeSpreadsheet():
    # Create a new excel file
    file = xlwt.Workbook()
    # Create a new sheet in the excel file
    sh = file.add_sheet('Sheet 1')

    # Write the titles to the respective row
    # Use the function write(row, col, val)
    # to write to sheet 1
    # Note: 0,0 is row 1,1 in the spreadsheet
    sh.write(0,0, 'Benchmarks')
    # Set width for benchmark col
    # 36.5714285 is about equal to 1 pixel
    # Width of 18 is 131 pixels
    sh.col(0).width = 4790

    # Write benchmark names
    row = 2
    for bench in benchmarks:
        sh.write(row, 0, bench)
        row += 1
    sh.write(row, 0, 'Total')

    # Begin writing stats for compile times
    col = 1
    for nameOfRun in benchStats:
        # Write run name
        row = 0
        sh.write(row, col, nameOfRun)

        for runNumber in benchStats[nameOfRun]:
            # Write run number
            row = 1
            sh.write(row, col, 'Run {}'.format(runNumber))
            row += 1

            # Write compile time stats
            for bench in benchStats[nameOfRun][runNumber]:
                if (bench == 'total_exe_time'):
                    sh.write(row, col, benchStats[nameOfRun][runNumber][bench])
                elif (bench == 'total_compile_time'):
                    continue
                else:
                    sh.write(row, col, benchStats[nameOfRun][runNumber][bench]['execution_time'])
                row += 1

            # Go to next column for the next run.
            col += 1

    # Save file to current directory.
    file.save('execution_time.xls')

# Create examples per second excel spreadsheet
def CreateEPSSpreadsheet():
    # Create a new excel file
    file = xlwt.Workbook()
    # Create a new sheet in the excel file
    sh = file.add_sheet('Sheet 1')

    # Write the titles to the respective row
    # Use the function write(row, col, val)
    # to write to sheet 1
    # Note: 0,0 is row 1,1 in the spreadsheet
    sh.write(0,0, 'Benchmarks')
    # Set width for benchmark col
    # 36.5714285 is about equal to 1 pixel
    # Width of 18 is 131 pixels
    sh.col(0).width = 4790

    # Write benchmark names
    row = 2
    for bench in benchmarks:
        sh.write(row, 0, bench)
        row += 1

    # Begin writing stats for compile times
    col = 1
    for nameOfRun in benchStats:
        # Write run name
        row = 0
        sh.write(row, col, nameOfRun)

        # Begin writing stats for examples per second
        for runNumber in benchStats[nameOfRun]:
            # Write run number
            row = 1
            sh.write(row, col, 'Run {}'.format(runNumber))
            row += 1

            for bench in benchStats[nameOfRun][runNumber]:
                if ((bench == 'total_compile_time') or (bench == 'total_exe_time')):
                    continue
                else:
                    # Calculate examples per second stat then write to spreadsheet
                    examplesPerSecond = 1000.00 / benchStats[nameOfRun][runNumber][bench]['inference_lat']
                    sh.write(row, col, examplesPerSecond)
                row += 1

            # Go to next column for the next run.
            col += 1

    # Save file to current directory.
    file.save('examples-per-second.xls')

# Create examples per second excel spreadsheet
def CreateTPSSpreadsheet():
    # Create a new excel file
    file = xlwt.Workbook()
    # Create a new sheet in the excel file
    sh = file.add_sheet('Sheet 1')

    # Write the titles to the respective row
    # Use the function write(row, col, val)
    # to write to sheet 1
    # Note: 0,0 is row 1,1 in the spreadsheet
    sh.write(0,0, 'Benchmarks')
    # Set width for benchmark col
    # 36.5714285 is about equal to 1 pixel
    # Width of 18 is 131 pixels
    sh.col(0).width = 4790

    # Write benchmark names
    row = 2
    for bench in benchmarks:
        sh.write(row, 0, bench)
        row += 1

    col = 1
    for nameOfRun in benchStats:
        # Write run name
        row = 0
        sh.write(row, col, nameOfRun)

        for runNumber in benchStats[nameOfRun]:
            # Write run number
            row = 1
            sh.write(row, col, 'Run {}'.format(runNumber))
            row += 1

            for bench in benchStats[nameOfRun][runNumber]:
                if ((bench == 'total_compile_time') or (bench == 'total_exe_time')):
                    continue
                else:
                    # Get the tiles per second (FPS) from benchStats and write it to
                    # the spreadsheet.
                    fps = benchStats[nameOfRun][runNumber][bench]['fps']
                    sh.write(row, col, fps)
                row += 1

            # Go to next column for the next run.
            col += 1

    # Save file to current directory.
    file.save('tiles-per-second.xls')

def main(args):
    # Parse folders to ignore into a list
    ignoreFolders = args.ignoreFolders.split(',')

    # Start stats collection
    parseStats(args.inputFolder, ignoreFolders)

    if args.verbose:
        printStats()

    if not args.disable:
        CreateCompileTimeSpreadsheet()
        CreateEPSSpreadsheet()
        CreateTPSSpreadsheet()
        CreateExecutionTimeSpreadsheet()

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Script to extract plaidbench data.',
                                      formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('--verbose', '-v',
                        action='store_true', default=False,
                        dest='verbose',
                        help='Print stats to terminal')

    parser.add_argument('--disable', '-d',
                        action='store_true', default=False,
                        dest='disable',
                        help='Disable spreadsheet output.')

    parser.add_argument('--input', '-i',
                        default='.',
                        dest='inputFolder',
                        help='The path to scan for benchmark directories')

    parser.add_argument('--ignore',
                        type=str,
                        default='',
                        dest='ignoreFolders',
                        help='List of folders to ignore separated by semi-colon')

    args = parser.parse_args()

    main(args)
